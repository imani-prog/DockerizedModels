package com.classicmodels.classicmodels.controllers;

import com.classicmodels.classicmodels.entities.Customer;
import com.classicmodels.classicmodels.entities.Payment;
import com.classicmodels.classicmodels.entities.PaymentId;
import com.classicmodels.classicmodels.repository.CustomerRepository;
import com.classicmodels.classicmodels.service.PaymentService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/payments")
@RequiredArgsConstructor
public class PaymentController {

    private final PaymentService paymentService;
    private final CustomerRepository customerRepository;


    @PostMapping("/save")
    public ResponseEntity<?> savePayment(@RequestBody Map<String, Object> paymentData) {
        try {
            // Extract data from the request with proper type handling
            Object customerNumberObj = paymentData.get("customerNumber");
            String paymentDateStr = (String) paymentData.get("paymentDate");
            Object amountObj = paymentData.get("amount");

            // Convert customerNumber to Integer safely
            Integer customerNumber = null;
            if (customerNumberObj != null) {
                if (customerNumberObj instanceof Integer) {
                    customerNumber = (Integer) customerNumberObj;
                } else if (customerNumberObj instanceof Number) {
                    customerNumber = ((Number) customerNumberObj).intValue();
                } else {
                    customerNumber = Integer.valueOf(customerNumberObj.toString());
                }
            }

            // Validate required fields
            if (customerNumber == null) {
                return ResponseEntity.badRequest().body("Customer number is required.");
            }

            System.out.println("Received customerNumber: " + customerNumber);
            System.out.println("Received paymentDate: " + paymentDateStr);
            System.out.println("Received amount: " + amountObj);

            // Validate that customer exists
            if (!customerRepository.existsById(customerNumber)) {
                return ResponseEntity.badRequest().body("Customer not found with ID: " + customerNumber);
            }

            // Create payment object
            Payment payment = new Payment();

            // Set payment date
            if (paymentDateStr != null) {
                payment.setPaymentDate(LocalDate.parse(paymentDateStr));
            }

            // Set amount
            if (amountObj != null) {
                BigDecimal amount = new BigDecimal(amountObj.toString());
                payment.setAmount(amount);
            }

            // Set customer
            Customer customer = customerRepository.getReferenceById(customerNumber);
            payment.setCustomer(customer);

            // Save payment (checkNumber will be auto-generated by the service)
            Payment savedPayment = paymentService.savePayment(payment);
            return ResponseEntity.ok(savedPayment);

        } catch (Exception e) {
            System.err.println("Error saving payment: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.badRequest().body("Error saving payment: " + e.getMessage());
        }
    }

    @PostMapping("/saveBatch")
    public ResponseEntity<List<Payment>> savePayments(@RequestBody List<Payment> payments) {
        try {
            List<Payment> savedPayments = payments.stream()
                    .map(payment -> {
                        if (payment.getCustomer() == null || payment.getCustomer().getCustomerNumber() == null) {
                            throw new IllegalArgumentException("Customer number is required for each payment.");
                        }
                        Integer customerNumber = payment.getCustomer().getCustomerNumber();
                        payment.setCustomer(customerRepository.getReferenceById(customerNumber));
                        return paymentService.savePayment(payment);
                    })
                    .toList();
            return ResponseEntity.ok(savedPayments);
        } catch (Exception e) {
            System.err.println("Error saving batch payments: " + e.getMessage());
            return ResponseEntity.internalServerError().build();
        }
    }

    @GetMapping
    public ResponseEntity<List<Payment>> getAllPayments() {
        return ResponseEntity.ok(paymentService.getAllPayments());
    }

    @GetMapping("/{customerNumber}/{checkNumber}")
    public ResponseEntity<Payment> getPaymentById(@PathVariable Integer customerNumber, @PathVariable String checkNumber) {
        PaymentId id = new PaymentId();
        id.setCustomerNumber(customerNumber);
        id.setCheckNumber(checkNumber);
        return paymentService.getPaymentById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PutMapping("/{customerNumber}/{checkNumber}")
    public ResponseEntity<Payment> updatePayment(@PathVariable Integer customerNumber, @PathVariable String checkNumber, @RequestBody Payment payment) {
        PaymentId id = new PaymentId();
        id.setCustomerNumber(customerNumber);
        id.setCheckNumber(checkNumber);
        customerRepository.findById(customerNumber)
                .orElseThrow(() -> new IllegalArgumentException("Customer not found with ID: " + customerNumber));

        payment.setCustomer(customerRepository.getReferenceById(customerNumber));

        Payment updated = paymentService.updatePayment(id, payment);
        return updated != null ? ResponseEntity.ok(updated) : ResponseEntity.notFound().build();
    }

    @DeleteMapping("/{customerNumber}/{checkNumber}")
    public ResponseEntity<Void> deletePayment(@PathVariable Integer customerNumber, @PathVariable String checkNumber) {
        PaymentId id = new PaymentId();
        id.setCustomerNumber(customerNumber);
        id.setCheckNumber(checkNumber);
        boolean deleted = paymentService.deletePayment(id);
        return deleted ? ResponseEntity.noContent().build() : ResponseEntity.notFound().build();
    }
}
